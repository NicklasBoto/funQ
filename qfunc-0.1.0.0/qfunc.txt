-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/NicklasBoto/qfunc#readme</a>
@package qfunc
@version 0.1.0.0


-- | Definition of the quantum monad (<a>QM</a>) and helper functions
module QM

-- | The Quantum Monad Keeps a state of the complex vector representation
--   while allowing pseudo-random number generation
data QM a

-- | Run quantum program, discarding it's final state
run :: QM a -> IO a

-- | Run quantum program, prints the final quantum state and returns the
--   result
runDebug :: QM a -> IO a

-- | Run quantum program
eval :: QM a -> IO (a, QState)

-- | Replace the quantum state
put :: QState -> QM ()

-- | Fetch the quantum state
get :: QM QState

-- | Apply a function to the quantum state
modify :: (QState -> QState) -> QM ()

-- | Perform IO action inside the quantum monad
io :: IO a -> QM a

-- | The program state, a complex vector representation of the qubits in
--   the system
newtype QState
QState :: Vector C -> QState
[state] :: QState -> Vector C

-- | Internal index type, to indicate it is a qubit index.
type Ix = Int

-- | Pointer to a qubit in QState. Represents the linking function in
--   QLambda
newtype QBit
Ptr :: Ix -> QBit
[link] :: QBit -> Ix

-- | Print the quantum state during operation
checkState :: QM ()

-- | Returns the quantum state together with it's size
getState :: QM (QState, Int)

-- | Given a QState, returns how many qbits it consists of.
stateSize :: QState -> Ix
instance GHC.Show.Show QM.QBit
instance GHC.Show.Show (QM.QM a)
instance GHC.Base.Functor QM.QM
instance GHC.Base.Applicative QM.QM
instance GHC.Base.Monad QM.QM
instance GHC.Show.Show QM.QState


-- | Internal matrix operations
module Internal.Gates

-- | The imaginary unit
i :: Complex Double
applyParallel :: Matrix C -> Matrix C -> Matrix C

-- | Apply gate to the current quantum state
applyGate :: Matrix C -> QM ()

-- | Insert an element at a specific index in a list.
insertAt :: a -> Int -> [a] -> [a]

-- | Apply a 2x2 gate, to a specific qubit.
--   
--   It will update the qstate.
runGate :: Matrix C -> QBit -> QM QBit
parallel :: [Matrix C] -> QM ()

-- | Projection of the zero basis vector
proj0 :: Matrix C

-- | Projection of the one basis vector
proj1 :: Matrix C

-- | Produce matrix running a gate controlled by another bit
controlMatrix :: Int -> QBit -> QBit -> Matrix C -> Matrix C


-- | Internal matrix and measurment operations
module Internal.Core

-- | Appends state with tensor
appendState :: QState -> QState -> QState
tensorVector :: Vector C -> Vector C -> Vector C

-- | (probToBeZero, probToBeOne) ix is index of qubit to measure
findProb :: Ix -> QState -> (Rational, Rational)
remBadProbs :: Bit -> Ix -> QState -> QState
maskMatch :: Ix -> Ix -> Int -> Bool

-- | Vector state representations of qubits with 100% probaility to
--   collapse to their bit counterparts
newVector :: Bit -> QState


-- | Module containing unitary gates and their matrix representations.
module Gates

-- | Pauli-X gate
--   
--   &lt;math&gt;
--   
pauliX :: QBit -> QM QBit

-- | Pauli-Y gate
--   
--   &lt;math&gt;
--   
pauliY :: QBit -> QM QBit

-- | Pauli-Z gate
--   
--   &lt;math&gt;
--   
pauliZ :: QBit -> QM QBit

-- | Hadamard gate
--   
--   &lt;math&gt;
--   
hadamard :: QBit -> QM QBit

-- | Phase gate
--   
--   &lt;math&gt;
--   
phase :: QBit -> QM QBit

-- | Pi/8 gate (T gate)
--   
--   &lt;math&gt;
--   
phasePi8 :: QBit -> QM QBit

-- | CNOT gate
--   
--   &lt;math&gt;
--   
cnot :: (QBit, QBit) -> QM (QBit, QBit)

-- | Identity gate
--   
--   &lt;math&gt;
identity :: QBit -> QM QBit

-- | SWAP gate
--   
--   &lt;math&gt;
--   
swap :: (QBit, QBit) -> QM (QBit, QBit)


-- | The core language operations.
module Core

-- | Create new <a>QBit</a> from a bit. maps &lt;math&gt; and &lt;math&gt;
new :: Bit -> QM QBit

-- | Performs a measurement operation, collapsing a <a>QBit</a> to a
--   <a>Bit</a>. Here comes a long explanation of the algorithm correcting
--   the state
measure :: QBit -> QM Bit

-- | Sets a classical bit as the controlbit for a quantum gate. Making it
--   run only when the classical bit is equal to one.
controlbit :: QM a -> Bit -> QM ()

-- | Synonym for controlbit
(===) :: QM a -> Bit -> QM ()

-- | Print results from a 100 runs of a program
dist :: QM Bit -> IO ()

-- | Run a quantum program producing a single bit <tt>reps</tt> times and
--   print the results
ndist :: Int -> QM Bit -> IO ()
data Bit


-- | Exports the language and simulator
module FunQ

-- | Create new <a>QBit</a> from a bit. maps &lt;math&gt; and &lt;math&gt;
new :: Bit -> QM QBit

-- | Performs a measurement operation, collapsing a <a>QBit</a> to a
--   <a>Bit</a>. Here comes a long explanation of the algorithm correcting
--   the state
measure :: QBit -> QM Bit

-- | Run a quantum program producing a single bit <tt>reps</tt> times and
--   print the results
ndist :: Int -> QM Bit -> IO ()

-- | Print results from a 100 runs of a program
dist :: QM Bit -> IO ()

-- | Sets a classical bit as the controlbit for a quantum gate. Making it
--   run only when the classical bit is equal to one.
controlbit :: QM a -> Bit -> QM ()

-- | Pointer to a qubit in QState. Represents the linking function in
--   QLambda
data QBit
data Bit

-- | The Quantum Monad Keeps a state of the complex vector representation
--   while allowing pseudo-random number generation
data QM a

-- | Pauli-X gate
--   
--   &lt;math&gt;
--   
pauliX :: QBit -> QM QBit

-- | Pauli-Y gate
--   
--   &lt;math&gt;
--   
pauliY :: QBit -> QM QBit

-- | Pauli-Z gate
--   
--   &lt;math&gt;
--   
pauliZ :: QBit -> QM QBit

-- | Hadamard gate
--   
--   &lt;math&gt;
--   
hadamard :: QBit -> QM QBit

-- | Phase gate
--   
--   &lt;math&gt;
--   
phase :: QBit -> QM QBit

-- | Pi/8 gate (T gate)
--   
--   &lt;math&gt;
--   
phasePi8 :: QBit -> QM QBit

-- | CNOT gate
--   
--   &lt;math&gt;
--   
cnot :: (QBit, QBit) -> QM (QBit, QBit)

-- | Identity gate
--   
--   &lt;math&gt;
identity :: QBit -> QM QBit

-- | SWAP gate
--   
--   &lt;math&gt;
--   
swap :: (QBit, QBit) -> QM (QBit, QBit)

-- | Run quantum program, discarding it's final state
run :: QM a -> IO a

-- | Run quantum program, prints the final quantum state and returns the
--   result
runDebug :: QM a -> IO a

-- | Prepares bell state
bell :: (Bit, Bit) -> QM (QBit, QBit)

-- | Performs bell measurement
bellMeasure :: (QBit, QBit) -> QM (Bit, Bit)
