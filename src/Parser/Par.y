-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module Parser.Par
  ( happyError
  , myLexer
  , pProgram
  , pTerm2
  , pTerm1
  , pTerm
  , pBit
  , pFunDec
  , pListFunDec
  , pFunction
  , pArg
  , pListArg
  , pType
  , pListType
  , pGate
  ) where
import qualified Parser.Abs
import Parser.Lex
}

%name pProgram Program
%name pTerm2 Term2
%name pTerm1 Term1
%name pTerm Term
%name pBit Bit
%name pFunDec FunDec
%name pListFunDec ListFunDec
%name pFunction Function
%name pArg Arg
%name pListArg ListArg
%name pType Type
%name pListType ListType
%name pGate Gate
-- no lexer declaration
%monad { Either String } { (>>=) } { return }
%tokentype {Token}
%token
  '(' { PT _ (TS _ 1) }
  ')' { PT _ (TS _ 2) }
  '*' { PT _ (TS _ 3) }
  ',' { PT _ (TS _ 4) }
  '->' { PT _ (TS _ 5) }
  '-o' { PT _ (TS _ 6) }
  '0' { PT _ (TS _ 7) }
  '1' { PT _ (TS _ 8) }
  ':' { PT _ (TS _ 9) }
  '=' { PT _ (TS _ 10) }
  '><' { PT _ (TS _ 11) }
  'Bit' { PT _ (TS _ 12) }
  'CNOT' { PT _ (TS _ 13) }
  'FREDKIN' { PT _ (TS _ 14) }
  'H' { PT _ (TS _ 15) }
  'I' { PT _ (TS _ 16) }
  'QBit' { PT _ (TS _ 17) }
  'S' { PT _ (TS _ 18) }
  'SWAP' { PT _ (TS _ 19) }
  'T' { PT _ (TS _ 20) }
  'TOFFOLI' { PT _ (TS _ 21) }
  'X' { PT _ (TS _ 22) }
  'Y' { PT _ (TS _ 23) }
  'Z' { PT _ (TS _ 24) }
  'else' { PT _ (TS _ 25) }
  'if' { PT _ (TS _ 26) }
  'in' { PT _ (TS _ 27) }
  'let' { PT _ (TS _ 28) }
  'measure' { PT _ (TS _ 29) }
  'new' { PT _ (TS _ 30) }
  'then' { PT _ (TS _ 31) }
  L_Variable { PT _ (T_Variable $$) }
  L_GateIdent { PT _ (T_GateIdent $$) }
  L_Lambda { PT _ (T_Lambda $$) }

%%

Variable :: { Parser.Abs.Variable}
Variable  : L_Variable { Parser.Abs.Variable $1 }

GateIdent :: { Parser.Abs.GateIdent}
GateIdent  : L_GateIdent { Parser.Abs.GateIdent $1 }

Lambda :: { Parser.Abs.Lambda}
Lambda  : L_Lambda { Parser.Abs.Lambda $1 }

Program :: { Parser.Abs.Program }
Program : ListFunDec { Parser.Abs.PDef $1 }

Term2 :: { Parser.Abs.Term }
Term2 : Bit { Parser.Abs.TBit $1 }
      | Variable { Parser.Abs.TVar $1 }
      | '(' Term1 ',' Term1 ')' { Parser.Abs.TTup $2 $4 }
      | '(' Term ')' { $2 }

Term1 :: { Parser.Abs.Term }
Term1 : '*' { Parser.Abs.TStar }
      | 'measure' Term1 { Parser.Abs.TMeas $2 }
      | 'new' Term1 { Parser.Abs.TNew $2 }
      | Term1 Term2 { Parser.Abs.TApp $1 $2 }
      | Lambda Variable '->' Term { Parser.Abs.TLamb $1 $2 $4 }
      | 'if' Term 'then' Term 'else' Term { Parser.Abs.TIfEl $2 $4 $6 }
      | Gate { Parser.Abs.TGate $1 }
      | 'let' '(' Term ',' Term ')' '=' Term 'in' Term { Parser.Abs.TLet $3 $5 $8 $10 }
      | Term2 { $1 }

Term :: { Parser.Abs.Term }
Term : Term1 { $1 }

Bit :: { Parser.Abs.Bit }
Bit : '0' { Parser.Abs.BZero } | '1' { Parser.Abs.BOne }

FunDec :: { Parser.Abs.FunDec }
FunDec : Variable ':' ListType Function { Parser.Abs.FDecl $1 $3 $4 }

ListFunDec :: { [Parser.Abs.FunDec] }
ListFunDec : {- empty -} { [] } | FunDec ListFunDec { (:) $1 $2 }

Function :: { Parser.Abs.Function }
Function : Variable ListArg '=' Term { Parser.Abs.FDef $1 $2 $4 }

Arg :: { Parser.Abs.Arg }
Arg : Variable { Parser.Abs.FArg $1 }

ListArg :: { [Parser.Abs.Arg] }
ListArg : {- empty -} { [] } | Arg ListArg { (:) $1 $2 }

Type :: { Parser.Abs.Type }
Type : 'Bit' { Parser.Abs.TypeBit }
     | 'QBit' { Parser.Abs.TQbit }
     | 'T' { Parser.Abs.TVoid }
     | Type '><' Type { Parser.Abs.TTens $1 $3 }

ListType :: { [Parser.Abs.Type] }
ListType : {- empty -} { [] }
         | Type { (:[]) $1 }
         | Type '-o' ListType { (:) $1 $3 }

Gate :: { Parser.Abs.Gate }
Gate : 'H' { Parser.Abs.GH }
     | 'X' { Parser.Abs.GX }
     | 'Y' { Parser.Abs.GY }
     | 'Z' { Parser.Abs.GZ }
     | 'I' { Parser.Abs.GI }
     | 'S' { Parser.Abs.GS }
     | 'T' { Parser.Abs.GT }
     | 'CNOT' { Parser.Abs.GCNOT }
     | 'TOFFOLI' { Parser.Abs.GTOF }
     | 'SWAP' { Parser.Abs.GSWP }
     | 'FREDKIN' { Parser.Abs.GFRDK }
     | GateIdent { Parser.Abs.GGate $1 }
{

happyError :: [Token] -> Either String a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer = tokens
}

